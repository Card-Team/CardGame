@startuml
'Les champs ayant le stéréotype <<property>> sont des propriétés C#

class IDisposable

package EventSystem{
class EventManager{
'objet intermediaire qui cast pour appeler l'évenement
 + {field} <<delegate>> OnEvent<T extends Event>(T evt)
 - eventHandlersDict: Dictionary<Type,List<OnEvent>>
 
 + SubscribeToEvent <T extends Event>(deleg : OnEvent, evenCancelled : bool = false, postEvent: bool = false)
 + UnsubscribeFromEvent <T extends Event>(deleg : OnEvent, postEvent: bool = false)
 + SendEvent<T extends Event>(T evt,postEvent : bool = false) : PostEventSender
 'faut pas oublier d'envoyer les Post
 ' utilisation d'un bloc using
}

class EventManager::PostEventSender implements IDisposable{
 + <<property>> Event: Event
 + Dispose()
 'méthode qui s'occuppe d'appeler EventManager.SendEvent avec le meme event en post
}

class EventProperty<S,T,ET implements IPropertyEvent>{
 - sender : S
 + <<property>> Value : T {readOnly}
 
 + EventProperty(in sender: S)
 + TryChangeValue(in newVal: T)
}

!include EventsClassDiagram.puml
}

!include CardsClassDiagram.puml

package GameSystems{
class Effect{
+ <<property>> EffectType: EffectType {readOnly}
+ <<property>> EffectId : int {readOnly}
+ DoEffect(in theGame: Game): bool
'TODO Lua
}

enum EffectType{
    Artefact
    Keyword
    Card
}

class Player{
+ <<property>> Deck: CardPile
'+ <<property>> Artefacts: Artefact[2] {readOnly}
+ <<property>> Name: string {readOnly}
+ <<property>> Hand : CardPile
+ <<property>> ActionPoints : EventProperty<Player,int,ActionPointEditEvent> {readOnly}
+ <<property>> Discard : DiscardPile

+ DrawCard()
+ PrepareCardUpgrade(in theCard: Card)
+ LoopDeck()
+ DiscardCard(in theCard: Card)

}

Player  "2" *-r "1" Artefact : <<property>> Artefacts {readOnly}

package Targeting{

class Target{
+ <<property>> TargetType : TargetTypes {readOnly}
+ <<property>> IsAutomatic : bool
+ <<property>> Name: string

}
Effect "1" *--  "0..*" Target : <<property>> AllTargets {readOnly}


enum TargetTypes{
    Player
    Card
}
Target .l. TargetTypes
}
}



class EffectsDatabase{
- effectDictionary : Dictionary<int,Effect>
- LoadEffect(effectId: int) : Effect
+ LoadAllEffects(path: string)
}




class Game{

+ <<property>> CurrentPlayerTurn: Player {readOnly}
+ <<property>> EventManager: EventManager {readOnly}
+ <<property>> EffectsDatabase: EffectsDatabase {readOnly}

+ CheckHasWon(in playerToCheck: Player) : bool
+ StartPlayerTurn(in player: Player)
+ FinishTurn(in player: Player)
+ CanBePlayed(in by: Player,in theCard: Card)
+ PlayCard(in thePlayer: Player, in theCard: Card)
+ ActivateArtifact(in thePlayer: Player,in theArtefact: Artefact)
}



Player "1" --d-* "1" Game: <<property>> Player1 {readOnly}
Player "1" --d-* "1" Game: <<property>> Player2 {readOnly}



@enduml