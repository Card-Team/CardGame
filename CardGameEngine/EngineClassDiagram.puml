@startuml
'Les champs ayant le stéréotype <<property>> sont des propriétés C#

hide circle
skinparam classAttributeIconSize 0
skinparam linetype ortho

package EventSystem{
class EventManager{
'objet intermediaire qui cast pour appeler l'évenement
 + {field} <<delegate>> OnEvent<T extends Event>(T evt)
 - eventHandlersDict: Dictionary<Type,List<OnEvent>>
 
 + subscribeToEvent <T extends Event>(OnEven deleg)
 + unsubscribeFromEvent <T extends Event>(OnEven deleg)
 + sendEvent<T extends Event>(T evt)
}

package Events{

abstract class Event{
 + <<property>> Cancelled: bool = false
}

class TargetingEvent extends Event{
 + <<property>> TargetData: Target
}

package GameStateEvents{

class StartTurnEvent extends Event{
+ <<property>> Player: Player
}

class EndTurnEvent extends Event{
+ <<property>> Player: Player
}

package KeywordEvent{

'TODO

}


}

package CardEvents{

abstract class CardEvent extends Event{
 + <<property>> Card : Card
}


class CardUpgradeEvent extends CardEvent
class CardMovePileEvent extends CardEvent{
 + <<property>> SourcePile: CardPile
 + <<property>> DestPile: CardPile
}

class CardPlayEvent extends CardEvent
class CardMarkUpgradeEvent extends CardEvent
class CardDeleteEvent extends CardEvent



package PropertyChange{
abstract class CardPropertyChangeEvent<T> extends CardEvent{
 + <<property>> OldValue : T {readOnly}
 + <<property>> NewValue : T
}

CardNameChangeEvent --u|> CardPropertyChangeEvent : <<bind>>\nT=string
CardLevelChangeEvent --u|> CardPropertyChangeEvent : <<bind>>\nT=int
CardCostChangeEvent --u|> CardPropertyChangeEvent : <<bind>>\nT=int
CardEffectIdChangeEvent --u|> CardPropertyChangeEvent : <<bind>>\nT=int
'todo effect

}


}
}
}


package Cards{
class Card{
+ <<property>> Name : ObservableValue<string> {readOnly}
+ <<property>> MaxLevel : int {readOnly}
+ <<property>> Cost : ObservableValue<string> {readOnly}
+ CanBePlayedIn(in theGame: Game): bool
+ GetEffect(): Effect
}

class Keyword{
'TODO
}

package CardPiles{
class CardPile{
- cardList: Card[0..*]

+ {method} CardPile[int index] : Card
+ MoveTo(in currentCardPile: CardPile, in theCard: Card)
}
class DiscardPile extends CardPile{
+ <<property>> MarkedForUpgrade: Card[0..*]
}
}

class Artefact{
'TODO
+ <<property>> Name : DynamicValue<String> {readOnly}
+ CanBePlayedIn(in theGame: Game): bool
}
CardPile ..u|> IEnumerable : <<bind>>\nT=Card
Card "0..*" o--  "0..*" Keyword : <<property>> Keywords
Artefact "0..*" o--  "0..*" Keyword : <<property>> Keywords

}

class IEnumerable<T>{
+ GetEnumerator() : IEnumerator<T>
}







package GameSystems{
class Effect{
+ DoEffect(in theGame: Game): bool
'TODO
}

class Player{
+ <<property>> Deck: CardPile
'+ <<property>> Artefacts: Artefact[2] {readOnly}
+ <<property>> Name: string {readOnly}
+ <<property>> Hand : CardPile
+ <<property>> ActionPoints : ObservableValue<int> {readOnly}
+ <<property>> Discard : DiscardPile

+ DrawCard()
+ PrepareCardUpgrade(in theCard: Card)
+ LoopDeck()
+ DiscardCard(in theCard: Card)

}

Player  "2" *-r "1" Artefact : <<property>> Artefacts {readOnly}

package Targeting{

class Target{
+ <<property>> TargetType : TargetTypes {readOnly}
+ <<property>> IsAutomatic : bool
+ <<property>> Name: string

}
Effect "1" *--  "0..*" Target : <<property>> AllTargets {readOnly}


enum TargetTypes{
    Player
    Card
}
Target .l. TargetTypes
}
}








class Game{

+ <<property>> CurrentPlayerTurn: Player {readOnly}
+ <<property>> EventManager: EventManager {readOnly}

+ GameLoop()
+ CheckHasWon(in playerToCheck: Player) : bool
+ StartPlayerTurn(in player: Player)
+ FinishTurn(in player: Player)
+ PlayCard(in thePlayer: Player, in theCard: Card)
+ ActivateArtifact(in thePlayer: Player,in theArtefact: Artefact)
}



Player "1" --d-* "1" Game: <<property>> Player1 {readOnly}
Player "1" --d-* "1" Game: <<property>> Player2 {readOnly}



@enduml